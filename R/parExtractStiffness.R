parExtractStiffness=function(rBead, cases, zPos="zSensr", force="force", CPMaxF=.05, percentToFit=0.2, roughness=0.05,Q=.5, approachTrim=0.2, debug=FALSE, minRise=0, numCores=-1){

                                        #allCases is a list of curves to fit as generated by the identIter function, rBead is the bead radius, extZ and extForce are column vectors containing the position and force data, respectively. CPMaxF is the percentage of the maximum force beyond which this function will not test for the contact point. percentToFit is the percentage of the extension curve that will be used to perform the fits. roughness is the percent of the force range that features will have to be larger than to not be considered noise. Q is the minimum ratio of height to width a trough on a residual vs. contact point plot has to have to be considered a local minima. approachTrim is the percentage of the beginning of a curve to be trimmed off before performing fitting. Defaults for zPos and force correspond to the values used in data imported using loadIBW, batchLoad and quickLoad. numCores is the number of cores to use in order to do the calculation (if -1 is used, the function will use all available cores). Setting debug to TRUE causes the function to plot each fit (the user should press 'enter' to cycle through fits) in order to allow for tuning of fit parameters.
    if(numCores<0){
        numCores=detectCores()-1 #Default to giving R a bonus core to play with
    }

    parFun=function(case){
        print(case$ident)
        case$data=stripRet(case$data,zPos)
        toReturn=stiffnessSphereOnPlane(rBead, case$data[zPos][,], case$data[force][,], CPMaxF, percentToFit, roughness,Q,approachTrim,debug)
        return(list(fit=toReturn,ident=case$ident))
    }            
    if(debug){
        for(ca in cases){
            parFun(ca)
        }
    }
    fits=mclapply(cases,parFun,mc.cores=numCores)
    if(length(fits)!=length(cases)){
        print(paste("Parallel processing has resulted in dropped values, try again with a value of numCores smaller than",numCores))
        return(FALSE)
    }

    toReturn=list(fits=fits,rBead=rBead, zPos=zPos, force=force, CPMaxF=CPMaxF, percentToFit=percentToFit,roughness=roughness,Q=Q, approachTrim=approachTrim)
    if(minRise>0){
        fixFlatFits(toReturn,minRise,debug,numCores)

    }
    return(toReturn)
}
